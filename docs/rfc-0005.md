# RFC 0005: Modo Estrito e Verificação Offline (BSP v5)

**Status**: Implementado
**Versão**: BSP v5
**Data**: 2026-02-16

## Resumo

O BSP v5 introduz duas funcionalidades críticas: o modo de verificação estrito que aborta em qualquer falha de integridade, e a verificação offline de metadados que verifica a autenticidade e a estrutura sem acessar a Biblioteca de Babel.

## 1. Motivação

### 1.1 Modo Estrito

**Problema**: O comportamento padrão registra avisos, mas continua com dados corrompidos.

**Solução**: O modo `--strict` aborta imediatamente em caso de:
*   Incompatibilidade de hash de chunk
*   Incompatibilidade de hash de arquivo
*   Coordenadas ausentes
*   Falha na verificação de assinatura
*   Incompatibilidade na contagem de chunks

### 1.2 Verificação Offline

**Problema**: A verificação da integridade do arquivo requer o download de todos os chunks.

**Solução**: A verificação offline verifica:
*   Validade da assinatura RSA (se presente)
*   Integridade da estrutura JSON dos metadados
*   Presença e tipos de campos
*   Não requer acesso à rede

## 2. Especificação do Modo Estrito

### 2.1 Ativação

```bash
# CLI
python babel_storage.py download file.json.gz \
  --output restored.pdf \
  --strict

# API Python
download_file(metadata, output, strict=True)
```

### 2.2 Comportamento

| Verificação | Modo Normal | Modo Estrito |
|-------------|-------------|--------------|
| Incompatibilidade de hash de chunk | ⚠️ Aviso, continuar | ❌ Abortar imediatamente |
| Incompatibilidade de hash de arquivo | ⚠️ Aviso, retornar erro | ❌ Abortar, excluir arquivo |
| Coordenadas ausentes | ⚠️ Aviso, pular chunk | ❌ Abortar imediatamente |
| Assinatura inválida | ⚠️ Aviso, continuar | ❌ Abortar imediatamente |
| Contagem de chunks errada | ⚠️ Aviso, reconstruir | ❌ Abortar imediatamente |

### 2.3 Implementação

```python
def verify_chunk_strict(chunk_data: bytes, 
                       expected_hash: str,
                       chunk_index: int) -> bytes:
    """Verifica chunk em modo estrito."""
    actual_hash = hashlib.sha256(chunk_data).hexdigest()
    
    if actual_hash != expected_hash:
        raise RuntimeError(
            f"MODO ESTRICTO: Incompatibilidade de SHA-256 do chunk {chunk_index}\n"
            f"  Esperado: {expected_hash}\n"
            f"  Obtido:      {actual_hash}\n"
            f"  Abortando download."
        )
    
    return chunk_data
```

### 2.4 Códigos de Saída

| Cenário | Código de Saída | Descrição |
|----------|-----------|-------------|
| Sucesso | 0 | Todas as verificações passaram |
| Falha na verificação de chunk | 1 | Incompatibilidade de hash em modo estrito |
| Falha na verificação de arquivo | 2 | Incompatibilidade de hash final |
| Assinatura inválida | 3 | Falha na verificação de assinatura RSA |
| Dados ausentes | 4 | Campos obrigatórios ausentes |

## 3. Verificação Offline

### 3.1 O que é Verificado

**Verificações offline** (sem rede):
1.  ✅ Assinatura RSA (se presente)
2.  ✅ Validade da estrutura JSON
3.  ✅ Campos obrigatórios presentes
4.  ✅ Consistência da contagem de chunks
5.  ✅ Formatos de campo de hash (hex, 64 caracteres)
6.  ✅ Estrutura de coordenadas (se presente)

**NÃO verificado offline**:
*   ❌ Existência real do arquivo
*   ❌ Recuperabilidade de chunks da Babel
*   ❌ Integridade dos dados codificados

### 3.2 Uso da CLI

```bash
python babel_storage.py verify-metadata file.json.gz \
  --pubkey public.pem \
  --strict
```

**Exemplo de saída:**
```
Verificando assinatura de metadados...
  ✓ Assinatura válida
  ✓ Estrutura de metadados verificada
  ✓ Contagem de chunks consistente (38 chunks)
  ✓ Todas as entradas de chunk possuem hashes SHA-256
  ✓ Estrutura de coordenadas válida

Verificação offline APROVADA
```

### 3.3 Implementação

```python
def verify_metadata_only(metadata_path: str, 
                        public_key_path: str,
                        strict: bool = False) -> bool:
    """Verifica metadados offline."""
    metadata = FileMetadata.load(metadata_path)
    
    # 1. Verificar assinatura
    if not metadata.verify_signature(public_key_path):
        if strict:
            raise RuntimeError("Assinatura de metadados inválida")
        else:
            print("AVISO: Assinatura inválida")
            return False
    
    # 2. Verificar estrutura
    if metadata.chunk_count != len(metadata.chunks):
        if strict:
            raise RuntimeError("Incompatibilidade na contagem de chunks")
        else:
            print("AVISO: Contagem de chunks inconsistente")
            return False
    
    # 3. Validar hashes
    for i, chunk in enumerate(metadata.chunks):
        if not chunk.chunk_hash:
            if strict:
                raise RuntimeError(f"Hash ausente para o chunk {i}")
            else:
                print(f"AVISO: Chunk {i} com hash ausente")
        
        # Verificar formato do hash (64 caracteres hexadecimais)
        if len(chunk.chunk_hash) != 64:
            if strict:
                raise RuntimeError(f"Formato de hash inválido: chunk {i}")
    
    # 4. Verificar coordenadas (se carregadas)
    for chunk in metadata.chunks:
        if chunk.babel_coords:
            required = [\"hex\", \"wall\", \"shelf\", \"volume\", \"page\"]
            if not all(k in chunk.babel_coords for k in required):
                if strict:
                    raise RuntimeError("Coordenadas incompletas")
    
    return True
```

## 4. Casos de Uso

### 4.1 Downloads de Produção

**Modo estrito recomendado:**
```bash
# Recuperação de arquivo crítico
python babel_storage.py download backup.json.gz \
  --output restored_db.sql \
  --pubkey production.pub \
  --strict
```

### 4.2 Desenvolvimento/Testes

**Modo normal aceitável:**
```bash
# Testando com dados potencialmente corrompidos
python babel_storage.py download test.json.gz \
  --output test_output.dat
```

### 4.3 Auditoria de Metadados

**Verificação offline:**
```bash
# Auditar 100 arquivos de metadados
for f in metadata/*.json.gz; do
  python babel_storage.py verify-metadata "$f" \
    --pubkey audit.pub --strict
done
```

### 4.4 Integração CI/CD

```yaml
# Exemplo GitHub Actions
- name: Verificar integridade do backup
  run: |
    python babel_storage.py verify-metadata backup.json.gz \
      --pubkey ${{ secrets.PUBLIC_KEY }} \
      --strict
```

## 5. Mensagens de Erro

### 5.1 Erros do Modo Estrito

**Falha na verificação de chunk:**
```
[ERRO] MODO ESTRICTO: Incompatibilidade de SHA-256 do chunk 15
  Esperado: 2f4a8d9c1e3b5a7f9876543210abcdef...
  Obtido:      a1b2c3d4e5f67890fedcba0987654321...
  Abortando download no chunk 15/38
  Arquivo parcial excluído: /tmp/restore_partial.pdf
```

**Falha na verificação de arquivo:**
```
[ERRO] MODO ESTRICTO: Incompatibilidade de SHA-256 do arquivo final
  Esperado: 8a3f4f2288a5fba5f76d3c8f5e9a1b4c...
  Obtido:      b1c2d3e4f5g6h7i8j9k0l1m2n3o4p5q6...
  Arquivo baixado excluído: restored.pdf
```

### 5.2 Erros de Verificação Offline

**Falha na assinatura:**
```
[ERRO] A verificação da assinatura de metadados FALHOU
  Arquivo: document.json.gz
  Chave pública: public.pem
  Causas possíveis:
    - Metadados foram modificados após a assinatura
    - Chave pública errada usada
    - Corrupção da assinatura
```

**Falha na estrutura:**
```
[ERRO] Estrutura de metadados inválida
  Arquivo: document.json.gz
  Problema: Incompatibilidade na contagem de chunks
    Declarado: 38 chunks
    Encontrado:    37 entradas de chunk
```

## 6. Melhores Práticas

### 6.1 Quando Usar o Modo Estrito

**Use o modo estrito:**
*   ✅ Recuperação de dados de produção
*   ✅ Restauração de backup crítico
*   ✅ Downloads exigidos por conformidade
*   ✅ Sistemas automatizados

**Modo normal aceitável:**
*   Testes e desenvolvimento
*   Arquivos não críticos
*   Depuração de dados corrompidos

### 6.2 Quando Usar a Verificação Offline

**Use a verificação offline:**
*   ✅ Antes de iniciar downloads grandes
*   ✅ Auditoria da integridade do backup
*   ✅ Validação de metadados CI/CD
*   ✅ Verificações rápidas de sanidade

## 7. Considerações de Segurança

### 7.1 Defesa em Profundidade

O modo estrito oferece múltiplas camadas de verificação:
1.  Assinatura (autenticidade)
2.  Hash por chunk (integridade granular)
3.  Hash do arquivo (integridade de ponta a ponta)
4.  Validação da estrutura (consistência)

### 7.2 Resistência a Ataques

**O modo estrito protege contra:**
*   ✅ Metadados modificados
*   ✅ Chunks corrompidos
*   ✅ Downloads incompletos
*   ✅ Ataques de repetição (com timestamps)

## 8. Impacto no Desempenho

| Operação | Modo Normal | Modo Estrito | Sobrecarga |
|-----------|-------------|-------------|----------|
| Upload | ~1.5s/chunk | ~1.5s/chunk | 0% |
| Download | ~1.0s/chunk | ~1.0s/chunk | <1% |
| Verificar metadados | N/A | ~10ms | Desprezível |
| Chunk falho | Continuar | Abortar | Saída antecipada |

**O modo estrito é mais rápido em caso de falha** (aborta imediatamente).

## Referências

*   [RFC 0001](rfc-0001.md) - Integridade no Nível do Arquivo
*   [RFC 0002](rfc-0002.md) - Checksums por Chunk
*   [RFC 0004](rfc-0004.md) - Assinatura de Metadados

---

**Direitos Autorais**: Licença MIT
