# RFC 0004: Assinatura de Metadados (BSP v4)

**Status**: Implementado
**Versão**: BSP v4
**Data**: 2026-02-16

## Resumo

Esta especificação define assinaturas digitais RSA-PSS para metadados do BabelStorage, fornecendo autenticidade e verificação de integridade. Metadados assinados garantem que as coordenadas do arquivo e os checksums não foram adulterados.

## 1. Motivação

Sem assinaturas, um atacante poderia:
*   Modificar metadados para apontar para chunks diferentes
*   Alterar checksums esperados para ocultar corrupção
*   Substituir metadados de arquivo inteiros

As assinaturas fornecem:
*   **Autenticidade**: Verifica o criador dos metadados
*   **Integridade**: Detecta modificações
*   **Não Repúdio**: O signatário não pode negar a criação dos metadados

## 2. Algoritmo

### 2.1 RSA-PSS

**Algoritmo**: RSA-PSS (Probabilistic Signature Scheme)
**Hash**: SHA-256
**MGF**: MGF1 com SHA-256
**Comprimento do Salt**: PSS.MAX_LENGTH
**Tamanho da Chave**: 4096 bits (mínimo recomendado)

### 2.2 Geração de Chaves

```python
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend

private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=4096,
    backend=default_backend()
)
```

## 3. Processo de Assinatura

### 3.1 JSON Canônico

Os metadados DEVEM ser serializados deterministicamente:

```python
import json

canonical = json.dumps(
    metadata_dict,
    sort_keys=True,
    separators=(\'\', \':\')
)
```

### 3.2 Geração de Assinatura

```python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding

signature = private_key.sign(
    canonical.encode(\'utf-8\'),
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH
    ),
    hashes.SHA256()
)

sig_base64 = base64.b64encode(signature).decode(\'utf-8\')
```

### 3.3 Armazenamento

A assinatura é armazenada nos metadados como base64:

```json
{
  "f": "document.pdf",
  "s": 92079,
  "h": "8a3f4f22...",
  "c": 38,
  "v": "v5",
  "chk": [...],
  "sig": "MEUCIQDx3y8z7F..."
}
```

## 4. Processo de Verificação

### 4.1 Extrair Assinatura

```python
# Carregar metadados
with gzip.open(metadata_path, \'rt\') as f:
    full_metadata = json.load(f)

signature_b64 = full_metadata.pop(\'sig\')
signature = base64.b64decode(signature_b64)
```

### 4.2 Verificar Assinatura

```python
# JSON Canônico (sem o campo sig)
canonical = json.dumps(
    full_metadata,
    sort_keys=True,
    separators=(\'\', \':\')
)

# Verificar
try:
    public_key.verify(
        signature,
        canonical.encode(\'utf-8\'),
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    print("✓ Assinatura válida")
except Exception:
    print("✗ Assinatura inválida")
```

## 5. Gerenciamento de Chaves

### 5.1 Segurança da Chave Privada

**Armazenamento:**
*   Sistema de arquivos criptografado
*   Módulo de Segurança de Hardware (HSM)
*   Arquivos de chave protegidos por senha
*   **NUNCA** enviar para controle de versão

**Permissões:**
```bash
chmod 600 private.pem
```

### 5.2 Distribuição de Chave Pública

As chaves públicas podem ser distribuídas livremente:
*   Incluídas no repositório
*   Hospedadas em site
*   Compartilhadas por e-mail
*   Publicadas via keyserver

### 5.3 Rotação de Chaves

Ao rotacionar chaves:
1.  Gerar novo par de chaves
2.  Reassinar metadados existentes com a nova chave
3.  Distribuir a nova chave pública
4.  Destruir com segurança a chave privada antiga

## 6. Estrutura de Metadados

### 6.1 Campos Assináveis

A assinatura cobre:
*   `f` (nome do arquivo)
*   `s` (tamanho do arquivo)
*   `h` (hash do arquivo)
*   `c` (contagem de chunks)
*   `v` (versão do protocolo)
*   `chk` (array de chunks)

### 6.2 Campos Não Assináveis

A assinatura NÃO cobre:
*   O próprio campo `sig`
*   Tempos de modificação do arquivo
*   Metadados externos

## 7. Considerações de Segurança

### 7.1 Força Criptográfica

**RSA-PSS com chave de 4096 bits:**
*   Nível de segurança: ~152 bits
*   Resistente a computadores quânticos: Não (requer 15360+ bits)
*   Longevidade esperada: 2030+

**SHA-256:**
*   Resistência a colisões: 128 bits
*   Resistência a pré-imagem: 256 bits
*   Status: Seguro (nenhum ataque prático conhecido)

### 7.2 Vetores de Ataque

**Protegido:**
*   ✅ Adulteração de metadados
*   ✅ Man-in-the-middle
*   ✅ Substituição de chunk (com hashes de chunk)

**Não Protegido:**
*   ❌ Comprometimento da chave privada
*   ❌ Ataques de computador quântico (preocupação futura)
*   ❌ Vulnerabilidades de implementação

## 8. Implementação

### 8.1 Uso da CLI

**Assinar durante o upload:**
```bash
python babel_storage.py upload file.pdf \
  --metadata file.json.gz \
  --privkey private.pem
```

**Verificar durante o download:**
```bash
python babel_storage.py download file.json.gz \
  --output restored.pdf \
  --pubkey public.pem \
  --strict
```

**Verificar offline:**
```bash
python babel_storage.py verify-metadata file.json.gz \
  --pubkey public.pem
```

### 8.2 API Python

```python
from crypto_utils import sign_metadata, verify_metadata_signature

# Assinar
signature = sign_metadata(metadata_dict, \'private.pem\')

# Verificar
is_valid = verify_metadata_signature(
    metadata_dict, 
    \'public.pem\', 
    signature
)
```

## 9. Vetores de Teste

### Exemplo de Metadados (não assinados)

```json
{
  "f": "test.txt",
  "s": 11,
  "h": "a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447",
  "c": 1,
  "v": "v5",
  "chk": [[11, "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"]]
}
```

### Forma Canônica (para assinatura)

```
{"c":1,"chk":[[11,"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"]],"f":"test.txt","h":"a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447","s":11,"v":"v5"}
```

## Referências

*   [RFC 8017](https://tools.ietf.org/html/rfc8017) - PKCS #1: Especificações de Criptografia RSA
*   [RFC 0001](rfc-0001.md) - Integridade no Nível do Arquivo
*   [RFC 0002](rfc-0002.md) - Checksums por Chunk

---

**Direitos Autorais**: Licença MIT
