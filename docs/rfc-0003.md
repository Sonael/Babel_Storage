# RFC 0003: Especificação de Codificação Binária

**Status**: Implementado
**Versão**: BSP v1-v5
**Data**: 2026-02-16

## Resumo

Este documento especifica a codificação binário-para-texto usada para representar chunks de arquivos arbitrários como texto válido da Biblioteca de Babel. A codificação usa um alfabeto de 29 caracteres e um formato de prefixo estruturado para garantir uma codificação determinística e reversível com sobrecarga mínima.

## 1. Alfabeto

A codificação usa o alfabeto de 29 caracteres da Biblioteca de Babel:

```
abcdefghijklmnopqrstuvwxyz .,
```

**Caracteres:**
*   Letras minúsculas: `a-z` (26 caracteres)
*   Espaço: ` ` (1 caractere)
*   Ponto: `.` (1 caractere)
*   Vírgula: `,` (1 caractere)

**Total: 29 caracteres (BASE = 29)**

## 2. Algoritmo de Codificação

### 2.1 Visão Geral

Dados binários são convertidos para representação em base-29 com um prefixo estruturado:

```
[versão][tamanho_bytes_tamanho][tamanho_bytes_codificado][tamanho_corpo_tamanho][tamanho_corpo_codificado][corpo]
```

### 2.2 Etapas de Codificação

```python
def encode_bytes_to_babel(data: bytes) -> str:
    """Codifica bytes para o alfabeto de Babel."""
    if not data:
        return ""
    
    byte_len = len(data)
    value = int.from_bytes(data, \'big\')
    
    # Codifica o corpo (inteiro grande para base29)
    body = encode_base29_int(value)
    body_len = len(body)
    
    # Codifica metadados
    byte_len_encoded = encode_base29_int(byte_len)
    byte_len_size = len(byte_len_encoded)
    
    body_len_encoded = encode_base29_int(body_len)
    body_len_size = len(body_len_encoded)
    
    # Verificação de segurança
    if byte_len_size >= 29 or body_len_size >= 29:
        raise ValueError("Estouro de prefixo")
    
    # Constrói prefixo
    prefix = (
        IDX_TO_CHAR[byte_len_size] +
        byte_len_encoded +
        IDX_TO_CHAR[body_len_size] +
        body_len_encoded
    )
    
    # Marcador de versão do encoding: 'd' (enc-v4, utilizado pelo BSP v4 e v5)
    return \'d\' + prefix + body
```

### 2.3 Codificação de Inteiro em Base-29

```python
def encode_base29_int(value: int) -> str:
    """Converte inteiro para string em base-29."""
    if value < 0:
        raise ValueError("Inteiros negativos não são suportados")
    
    if value == 0:
        return \'a\'  # IDX_TO_CHAR[0]
    
    digits = []
    while value > 0:
        digits.append(IDX_TO_CHAR[value % 29])
        value //= 29
    
    return \'\'.join(reversed(digits))
```

## 3. Algoritmo de Decodificação

### 3.1 Decodificação Versionada

```python
def decode_babel_to_bytes(encoded_text: str) -> bytes:
    """Decodifica texto de Babel para bytes."""
    if not encoded_text:
        return b""
    
    # Remove espaços em branco
    encoded_text = encoded_text.replace(\'\n\', \'\').replace(\'\r\', \'\')
    
    # Valida caracteres
    allowed = set(BABEL_ALPHABET)
    for c in encoded_text:
        if c not in allowed:
            raise ValueError(f"Caractere inválido: {c}")
    
    version = encoded_text[0]
    
    if version in (\'a\', \'b\', \'c\', \'d\'):  # Versionado
        return decode_structured(encoded_text[1:])
    else:  # Legado
        return decode_legacy(encoded_text)
```

### 3.2 Decodificador Estruturado

```python
def decode_structured(text: str) -> bytes:
    """Decodifica formato versionado."""
    pos = 0
    
    # Analisa byte_len_size
    byte_len_size = CHAR_TO_IDX[text[pos]]
    pos += 1
    
    # Analisa byte_len
    byte_len_encoded = text[pos:pos + byte_len_size]
    pos += byte_len_size
    byte_len = decode_base29_int(byte_len_encoded)
    
    # Analisa body_len_size
    body_len_size = CHAR_TO_IDX[text[pos]]
    pos += 1
    
    # Analisa body_len
    body_len_encoded = text[pos:pos + body_len_size]
    pos += body_len_size
    body_len = decode_base29_int(body_len_encoded)
    
    # Analisa corpo
    body = text[pos:pos + body_len]
    value = decode_base29_int(body)
    
    # Converte para bytes
    return value.to_bytes(byte_len, \'big\')
```

## 4. Cálculo de Sobrecarga

### 4.1 Sobrecarga Teórica

```
bits_por_caractere = log₂(29) ≈ 4.858
bytes_por_caractere = 8 / 4.858 ≈ 1.647

Sobrecarga ≈ 1.647×
```

### 4.2 Exemplo Prático

**Entrada**: 1000 bytes
**Codificado**: ~1647 caracteres (+ prefixo ~10 caracteres)
**Total**: ~1657 caracteres

## 5. Histórico de Versões

| Versão do Encoding | Marcador | Utilizado em | Alterações |
|---------------------|----------|--------------|------------|
| Legado | Nenhum | — | Nenhuma estrutura de prefixo |
| enc-v1 | `'a'` | BSP v1 | Estrutura de prefixo adicionada |
| enc-v2 | `'b'` | BSP v2 | Codificação de prefixo melhorada |
| enc-v3 | `'c'` | BSP v3 | Codificação de corpo otimizada |
| enc-v4 | `'d'` | BSP v4, BSP v5 | **Atual** |

**Nota**: A versão do encoding (enc-v4, marcador `'d'`) é independente da versão do protocolo BSP. O BSP v5 continua utilizando o encoding enc-v4 sem alterações no esquema de codificação.

## 6. Exemplos

### Exemplo 1: "hello"

**Entrada**: `b"hello"` (5 bytes = `0x68656c6c6f`)

**Codificação:**
```
byte_len = 5
value = 448378203247 (decimal)
body = "z,xgj.hk" (base-29)
body_len = 8

byte_len_encoded = "f" (5 em base-29)
byte_len_size = 1 → "b"

body_len_encoded = "i" (8 em base-29)
body_len_size = 1 → "b"

prefix = "b" + "f" + "b" + "i" = "bfbi"
result = "d" + "bfbi" + "z,xgj.hk" = "dbfbiz,xgj.hk"
```

**Saída**: `"dbfbiz,xgj.hk"`

### Exemplo 2: Byte único

**Entrada**: `b"\x42"` (1 byte = 66 decimal)

**Codificação:**
```
byte_len = 1
value = 66
body = "ci" (66 em base-29)
body_len = 2

prefix = "bbbc"
result = "dbbbcci"
```

**Saída**: `"dbbbcci"`

## 7. Considerações de Segurança

*   **Determinismo**: A mesma entrada sempre produz a mesma saída
*   **Reversibilidade**: Codificação/decodificação sem perdas
*   **Proteção contra Estouro**: Valida tamanho do prefixo < 29
*   **Validação de Caracteres**: Rejeita caracteres de alfabeto inválidos

## Referências

*   [RFC 0001](rfc-0001.md) - Integridade no Nível do Arquivo
*   [RFC 0002](rfc-0002.md) - Checksums por Chunk

---

**Direitos Autorais**: Licença MIT