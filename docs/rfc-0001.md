# RFC 0001: Integridade no Nível do Arquivo (BSP v1)

**Status**: Implementado
**Versão**: BSP v1
**Data**: 2026-02-16
**Autores**: Projeto BabelStorage

## Resumo

Este documento especifica o mecanismo fundamental de integridade do Protocolo BabelStorage (BSP): o checksum SHA-256 no nível do arquivo. Todo arquivo armazenado através do BabelStorage deve ter seu hash SHA-256 calculado a partir dos dados originais, não comprimidos, e armazenado nos metadados. Este hash serve como o principal mecanismo de verificação para garantir a integridade do arquivo após a reconstrução.

## Sumário

1.  [Introdução](#1-introdução)
2.  [Terminologia](#2-terminologia)
3.  [Especificação](#3-especificação)
4.  [Implementação](#4-implementação)
5.  [Considerações de Segurança](#5-considerações-de-segurança)
6.  [Exemplos](#6-exemplos)
7.  [Referências](#7-referências)

## 1. Introdução

### 1.1 Motivação

Quando arquivos são comprimidos, fragmentados, codificados e armazenados usando coordenadas distribuídas, deve haver um mecanismo para verificar se o arquivo reconstruído corresponde ao original. Sem verificações de integridade no nível do arquivo, a corrupção silenciosa poderia passar despercebida, levando à perda de dados.

### 1.2 Escopo

Esta RFC define:
*   O algoritmo de hashing (SHA-256)
*   Quando o hash é calculado (pré-compressão)
*   Como o hash é armazenado (campo de metadados)
*   Quando o hash é verificado (pós-reconstrução)
*   Tratamento de erros para incompatibilidades de hash

## 2. Terminologia

As palavras-chave "DEVE", "NÃO DEVE", "OBRIGATÓRIO", "SERÁ", "NÃO SERÁ", "DEVERIA", "NÃO DEVERIA", "RECOMENDADO", "PODE" e "OPCIONAL" neste documento devem ser interpretadas conforme descrito na RFC 2119.

**Termos:**
*   **Arquivo original**: O arquivo fornecido pelo usuário, antes de qualquer processamento
*   **Hash do arquivo**: O digest SHA-256 do arquivo original, representado como hexadecimal
*   **Arquivo reconstruído**: O arquivo após recuperação, decodificação e descompressão
*   **Metadados**: A estrutura JSON contendo informações e coordenadas do arquivo

## 3. Especificação

### 3.1 Algoritmo de Hash

O algoritmo de hashing DEVE ser SHA-256 conforme definido em FIPS 180-4.

**Propriedades:**
*   Comprimento da saída: 256 bits (32 bytes)
*   Representação: String hexadecimal em minúsculas (64 caracteres)
*   Resistência a colisões: ~2^128 operações
*   Resistência a pré-imagem: ~2^256 operações

### 3.2 Cálculo do Hash

#### 3.2.1 Momento

O hash do arquivo DEVE ser calculado a partir dos dados do arquivo original **antes** de qualquer etapa de processamento:

```
Arquivo Original → [Calcular SHA-256] → Hash
      ↓
  [Comprimir]
      ↓
   [Fragmentar]
      ↓
   [Codificar]
```

O hash NÃO DEVE ser calculado a partir de:
*   Dados comprimidos
*   Dados fragmentados
*   Dados codificados
*   Metadados

#### 3.2.2 Algoritmo

```python
import hashlib

def calculate_file_hash(filepath: str) -> str:
    """
    Calcula o hash SHA-256 do arquivo.
    
    Args:
        filepath: Caminho para o arquivo
        
    Returns:
        String hexadecimal em minúsculas (64 caracteres)
    """
    sha256 = hashlib.sha256()
    
    with open(filepath, \'rb\') as f:
        # Lê em chunks de 4KB para lidar com arquivos grandes
        for chunk in iter(lambda: f.read(4096), b\'\'):
            sha256.update(chunk)
    
    return sha256.hexdigest()
```

### 3.3 Armazenamento

#### 3.3.1 Campo de Metadados

O hash do arquivo DEVE ser armazenado nos metadados sob a chave `"h"` (ou `"file_hash"` no modo verboso).

**Especificação do campo:**
*   **Chave**: `"h"` (string)
*   **Valor**: Digest SHA-256 hexadecimal em minúsculas (string, 64 caracteres)
*   **Obrigatório**: SIM
*   **Nulo**: NÃO

#### 3.3.2 Exemplo

```json
{
  "f": "document.pdf",
  "s": 92079,
  "h": "8a3f4f2288a5fba5f76d3c8f5e9a1b4c2d7e3f8g9h0i1j2k3l4m5n6o7p8q9r0",
  "c": 38,
  "v": "v5"
}
```

### 3.4 Verificação

#### 3.4.1 Momento

O hash do arquivo DEVE ser verificado **após** a reconstrução completa:

```
Chunks Recuperados → [Decodificar] → [Reconstruir] → [Descomprimir] → Arquivo Reconstruído
                                                                      ↓
                                                              [Calcular SHA-256]
                                                                      ↓
                                                              [Comparar com metadata.h]
```

#### 3.4.2 Algoritmo de Verificação

```python
def verify_file_integrity(filepath: str, expected_hash: str) -> bool:
    """
    Verifica se o arquivo corresponde ao hash SHA-256 esperado.
    
    Args:
        filepath: Caminho para o arquivo reconstruído
        expected_hash: Hash esperado dos metadados
        
    Returns:
        True se os hashes corresponderem, False caso contrário
    """
    actual_hash = calculate_file_hash(filepath)
    return actual_hash == expected_hash.lower()
```

#### 3.4.3 Tratamento de Erros

Se a verificação falhar:

**No modo normal:**
*   Registrar aviso no stderr
*   Retornar status de erro
*   Manter arquivo reconstruído para inspeção

**No modo estrito (`--strict`):**
*   Levantar `RuntimeError` imediatamente
*   Excluir arquivo reconstruído
*   Sair com código de status diferente de zero

### 3.5 Compatibilidade de Versão de Metadados

Este mecanismo de integridade é OBRIGATÓRIO em todas as versões do BSP:
*   BSP v1: Introduzido
*   BSP v2-v5: Obrigatório (inalterado)

## 4. Implementação

### 4.1 Implementação de Referência

Veja `file_chunker.py`:

```python
def create_file_metadata(filepath: str) -> FileMetadata:
    """Cria metadados incluindo o hash do arquivo."""
    filename = os.path.basename(filepath)
    file_size = os.path.getsize(filepath)
    
    # BSP v1: Calcular hash do arquivo
    file_hash = calculate_file_hash(filepath)
    
    # ... restante do processamento ...
    
    return FileMetadata(
        filename=filename,
        original_size=file_size,
        file_hash=file_hash,
        # ... outros campos ...
    )
```

### 4.2 Considerações de Desempenho

**Uso de Memória:**
*   Leitura em fluxo (chunks de 4KB) garante uso de memória O(1)
*   Independente do tamanho do arquivo

**Uso de CPU:**
*   SHA-256 é limitado pela CPU (~400-600 MB/s em CPUs modernas)
*   Para arquivo de 100MB: ~0.15-0.25 segundos

**I/O:**
*   Leitura sequencial única de todo o arquivo
*   Ideal para HDD e SSD

## 5. Considerações de Segurança

### 5.1 Resistência a Colisões

SHA-256 fornece resistência a colisões de 128 bits. A probabilidade de dois arquivos diferentes terem o mesmo hash é de aproximadamente 2^-128, o que é computacionalmente inviável.

### 5.2 Resistência a Pré-imagem

SHA-256 fornece resistência a pré-imagem de 256 bits. Dado um hash, encontrar um arquivo que o produza é computacionalmente inviável.

### 5.3 Limitações

**Não Protegido Contra:**
*   **Metadados maliciosos**: Um atacante que pode modificar metadados pode alterar o hash esperado. É por isso que o BSP v4 adiciona assinaturas digitais.
*   **Ataques de extensão de comprimento**: Não aplicável, pois fazemos hash do arquivo completo, não de MACs em fluxo.

**Protegido Contra:**
*   ✅ Corrupção acidental durante a transmissão
*   ✅ Inversões de bit no armazenamento
*   ✅ Reconstrução incompleta do arquivo
*   ✅ Erros de descompressão

### 5.4 Agilidade Criptográfica

Versões futuras do BSP PODEM suportar algoritmos de hash alternativos (por exemplo, SHA-3, BLAKE3) adicionando um campo de identificador de algoritmo aos metadados. A especificação atual assume SHA-256.

## 6. Exemplos

### 6.1 Fluxo Completo

**Upload:**
```python
# 1. Calcular hash do arquivo original
file_hash = calculate_file_hash("document.pdf")
# Saída: "8a3f4f2288a5fba5f76d3c8f5e9a1b4c..."

# 2. Armazenar em metadados
metadata = FileMetadata(
    filename="document.pdf",
    original_size=92079,
    file_hash=file_hash,
    # ... outros campos ...
)

# 3. Salvar metadados
metadata.save("document.json.gz")
```

**Download:**
```python
# 1. Carregar metadados
metadata = FileMetadata.load("document.json.gz")
expected_hash = metadata.file_hash

# 2. Reconstruir arquivo
reconstruct_file_from_chunks(chunks, metadata, "restored.pdf")

# 3. Verificar integridade
actual_hash = calculate_file_hash("restored.pdf")

if actual_hash != expected_hash:
    raise RuntimeError(f"A verificação de integridade do arquivo falhou!\n"
                      f"  Esperado: {expected_hash}\n"
                      f"  Obtido:      {actual_hash}")
```

### 6.2 Vetores de Teste

**Entrada**: Arquivo vazio (0 bytes)
```
SHA-256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
```

**Entrada**: "hello world\n" (12 bytes, ASCII)
```
SHA-256: a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447
```

**Entrada**: Arquivo de 1MB de zeros
```
SHA-256: cd2662154e6d76b2b2b92e70c0cac3ccf534f9b74eb5b89819ec509083d00a50
```

## 7. Referências

### 7.1 Referências Normativas

*   [FIPS 180-4](https://csrc.nist.gov/publications/detail/fips/180/4/final) - Padrão de Hash Seguro (SHS)
*   [RFC 2119](https://tools.ietf.org/html/rfc2119) - Palavras-chave para uso em RFCs para Indicar Níveis de Requisito

### 7.2 Referências Informativas

*   [RFC 0002](rfc-0002.md) - Checksums por Chunk (BSP v2)
*   [RFC 0004](rfc-0004.md) - Assinatura de Metadados (BSP v4)

## Apêndice A: Registro de Alterações

*   **2026-02-16**: Versão inicial (especificação BSP v1)

## Apêndice B: Contribuidores

*   Equipe do Projeto BabelStorage

---

**Aviso de Direitos Autorais**: Este documento é lançado sob a Licença MIT.
